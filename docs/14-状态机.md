# ç¬¬ 14 è¯¾ï¼šçŠ¶æ€æœº ğŸ®

çŠ¶æ€æœºç®¡ç†æ¸¸æˆçš„ä¸åŒçŠ¶æ€ï¼ˆèœå•ã€æ¸¸æˆä¸­ã€æ¸¸æˆç»“æŸï¼‰ã€‚

---

## 14.1 ä»€ä¹ˆæ˜¯çŠ¶æ€æœºï¼Ÿ

çŠ¶æ€æœºæ˜¯ä¸€ç§ç®¡ç†ç¨‹åºçŠ¶æ€çš„æ–¹æ³•ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å¼€å§‹èœå•     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ æŒ‰ Enter
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æ¸¸æˆä¸­      â”‚â†â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
       â”‚ æ’å¢™           â”‚ æŒ‰ R
       â†“               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  æ¸¸æˆç»“æŸ     â”‚â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ æŒ‰ M
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å¼€å§‹èœå•     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 14.2 å®šä¹‰çŠ¶æ€

```c
typedef enum {
    STATE_MENU,       // å¼€å§‹èœå•
    STATE_PLAYING,    // æ¸¸æˆä¸­
    STATE_PAUSED,     // æš‚åœ
    STATE_GAME_OVER   // æ¸¸æˆç»“æŸ
} GameState;
```

---

## 14.3 çŠ¶æ€è½¬æ¢

```c
typedef struct {
    GameState state;
    GameState next_state;
} Game;

void change_state(Game* g, GameState new_state) {
    g->next_state = new_state;
}

void update_state(Game* g) {
    if (g->state != g->next_state) {
        // é€€å‡ºå½“å‰çŠ¶æ€
        state_exit(g->state);
        
        // è½¬æ¢åˆ°æ–°çŠ¶æ€
        g->state = g->next_state;
        
        // è¿›å…¥æ–°çŠ¶æ€
        state_enter(g->state);
    }
}
```

---

## 14.4 çŠ¶æ€å¤„ç†å‡½æ•°

```c
// æ¯ä¸ªçŠ¶æ€çš„å¤„ç†å‡½æ•°
void menu_update(Game* g);
void menu_render(Game* g);
void menu_input(Game* g, int key);

void game_update(Game* g);
void game_render(Game* g);
void game_input(Game* g, int key);

void gameover_update(Game* g);
void gameover_render(Game* g);
void gameover_input(Game* g, int key);
```

---

## 14.5 æ¸¸æˆå¾ªç¯ä¸­çš„çŠ¶æ€æœº

```c
void game_run(Game* g) {
    while (g->running) {
        // å¤„ç†è¾“å…¥
        int key = getch();
        
        switch (g->state) {
            case STATE_MENU:
                menu_input(g, key);
                break;
            case STATE_PLAYING:
                game_input(g, key);
                break;
            case STATE_GAME_OVER:
                gameover_input(g, key);
                break;
        }
        
        // æ›´æ–°çŠ¶æ€
        update_state(g);
        
        // æ›´æ–°é€»è¾‘
        switch (g->state) {
            case STATE_MENU:
                menu_update(g);
                break;
            case STATE_PLAYING:
                game_update(g);
                break;
            case STATE_GAME_OVER:
                gameover_update(g);
                break;
        }
        
        // æ¸²æŸ“
        switch (g->state) {
            case STATE_MENU:
                menu_render(g);
                break;
            case STATE_PLAYING:
                game_render(g);
                break;
            case STATE_GAME_OVER:
                gameover_render(g);
                break;
        }
        
        napms(16);
    }
}
```

---

## 14.6 çŠ¶æ€å¤„ç†å™¨ç»“æ„ä½“

```c
typedef struct {
    void (*update)(Game*);
    void (*render)(Game*);
    void (*input)(Game*, int);
    void (*enter)(Game*);
    void (*exit)(Game*);
} StateHandler;

// å®šä¹‰å„ä¸ªçŠ¶æ€çš„å¤„ç†å™¨
StateHandler menu_handler = {
    .update = menu_update,
    .render = menu_render,
    .input = menu_input,
    .enter = menu_enter,
    .exit = menu_exit
};

StateHandler game_handler = {
    .update = game_update,
    .render = game_render,
    .input = game_input,
    .enter = game_enter,
    .exit = game_exit
};

// ä½¿ç”¨
StateHandler* current_handler = &menu_handler;

void game_loop(Game* g) {
    while (g->running) {
        int key = getch();
        
        current_handler->input(g, key);
        current_handler->update(g);
        current_handler->render(g);
    }
}
```

---

## 14.7 å®Œæ•´ç¤ºä¾‹

```c
#include <ncurses.h>
#include <stdbool.h>

typedef enum {
    STATE_MENU,
    STATE_PLAYING,
    STATE_GAME_OVER
} State;

typedef struct {
    State state;
    State next_state;
    bool running;
    int x, y;
    int score;
} Game;

// èœå•
void menu_render(Game* g) {
    clear();
    mvprintw(10, 30, "=== SNAKE GAME ===");
    mvprintw(12, 28, "Press ENTER to start");
    mvprintw(14, 30, "Press Q to quit");
    refresh();
}

void menu_input(Game* g, int key) {
    if (key == '\n') {  // Enter
        g->next_state = STATE_PLAYING;
        g->x = 10; g->y = 10; g->score = 0;
    } else if (key == 'q') {
        g->running = false;
    }
}

// æ¸¸æˆ
void game_update(Game* g) {
    // ç§»åŠ¨é€»è¾‘
}

void game_render(Game* g) {
    clear();
    mvprintw(0, 0, "Score: %d", g->score);
    mvaddch(g->y, g->x, 'O');
    refresh();
}

void game_input(Game* g, int key) {
    if (key == KEY_UP) g->y--;
    else if (key == KEY_DOWN) g->y++;
    else if (key == KEY_LEFT) g->x--;
    else if (key == KEY_RIGHT) g->x++;
    else if (key == 'q') g->next_state = STATE_GAME_OVER;
}

// æ¸¸æˆç»“æŸ
void gameover_render(Game* g) {
    clear();
    mvprintw(10, 30, "GAME OVER");
    mvprintw(12, 28, "Final Score: %d", g->score);
    mvprintw(14, 26, "R to restart, M for menu");
    refresh();
}

void gameover_input(Game* g, int key) {
    if (key == 'r') {
        g->next_state = STATE_PLAYING;
        g->x = 10; g->y = 10; g->score = 0;
    } else if (key == 'm') {
        g->next_state = STATE_MENU;
    }
}

// ä¸»å¾ªç¯
void game_run(Game* g) {
    while (g->running) {
        // çŠ¶æ€è½¬æ¢
        if (g->state != g->next_state) {
            g->state = g->next_state;
        }
        
        int key = getch();
        
        switch (g->state) {
            case STATE_MENU:
                menu_input(g, key);
                menu_render(g);
                break;
            case STATE_PLAYING:
                game_input(g, key);
                game_update(g);
                game_render(g);
                break;
            case STATE_GAME_OVER:
                gameover_input(g, key);
                gameover_render(g);
                break;
        }
        
        napms(100);
    }
}

int main(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    
    Game game = {
        .state = STATE_MENU,
        .next_state = STATE_MENU,
        .running = true
    };
    
    game_run(&game);
    
    endwin();
    return 0;
}
```

---

## âœ… æœ¬è¯¾æ£€æŸ¥æ¸…å•

- [ ] ç†è§£çŠ¶æ€æœºçš„æ¦‚å¿µ
- [ ] ä¼šå®šä¹‰æ¸¸æˆçŠ¶æ€
- [ ] ä¼šå®ç°çŠ¶æ€è½¬æ¢
- [ ] èƒ½ä¸ºæ¯ä¸ªçŠ¶æ€ç¼–å†™å¤„ç†å‡½æ•°

---

## ğŸ“ ä½œä¸š

1. ä¸ºè´ªåƒè›‡æ·»åŠ æš‚åœçŠ¶æ€

2. å®ç°ä¸€ä¸ªè®¾ç½®èœå•çŠ¶æ€

3. æ·»åŠ çŠ¶æ€è½¬æ¢æ—¶çš„åŠ¨ç”»æ•ˆæœ

---

ä¸‹ä¸€è¯¾ï¼š[å®Œæˆä¸æ‰©å±•](15-å®Œæˆä¸æ‰©å±•.md)
